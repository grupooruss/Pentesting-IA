from art.attacks.extraction import FunctionallyEquivalentExtraction
from art.estimators.classification import PyTorchClassifier
from sklearn.model_selection import train_test_split
from sklearn import datasets
from torch.autograd import Variable
import torch.nn as nn
import torch.optim as optim
import numpy as np
import torch

# Carga un conjunto de datos de ejemplo
iris = datasets.load_iris()
X_train, X_test, y_train, y_test = train_test_split(iris.data, iris.target, test_size=0.2, random_state=42)

# Convierte los datos a tensores de PyTorch
X_train = torch.tensor(X_train, dtype=torch.float32)
X_test = torch.tensor(X_test, dtype=torch.float32)
y_train = torch.tensor(y_train, dtype=torch.long)
y_test = torch.tensor(y_test, dtype=torch.long)

# Crea y entrena un modelo de clasificaci칩n b치sico
model = nn.Linear(4, 3)
criterion = nn.CrossEntropyLoss()
optimizer = optim.Adam(model.parameters(), lr=0.01)
model.train()
for _ in range(1000):
    optimizer.zero_grad()
    output = model(X_train)
    loss = criterion(output, y_train)
    loss.backward()
    optimizer.step()

# Crea un clasificador ART a partir del modelo de PyTorch
art_classifier = PyTorchClassifier(model=model, clip_values=(0, 1), loss=criterion, optimizer=optimizer, input_shape=(4,), nb_classes=3)

# Crea un ataque de suplantaci칩n de modelo con ART
attack = FunctionallyEquivalentExtraction(art_classifier)

# Genera un modelo suplantado
model_surrogate = attack.extract(x=X_train.numpy(), y=y_train.numpy())

# Verifica la precisi칩n del modelo suplantado en el conjunto de prueba original
predictions = model_surrogate.predict(X_test.numpy())
accuracy = np.sum(np.argmax(predictions, axis=1) == y_test.numpy()) / len(y_test)
print(f'Accuracy of surrogate model on original test examples: {accuracy * 100}%')