from art.attacks.evasion import DeepFool
from art.estimators.classification import PyTorchClassifier
from sklearn.model_selection import train_test_split
from sklearn import datasets
from torch.autograd import Variable
import torch.nn as nn
import torch.optim as optim
import numpy as np
import torch

# Carga un conjunto de datos de ejemplo
iris = datasets.load_iris()
X_train, X_test, y_train, y_test = train_test_split(iris.data, iris.target, test_size=0.2, random_state=42)

# Convierte los datos a tensores de PyTorch
X_train = torch.tensor(X_train, dtype=torch.float32)
X_test = torch.tensor(X_test, dtype=torch.float32)
y_train = torch.tensor(y_train, dtype=torch.long)
y_test = torch.tensor(y_test, dtype=torch.long)

# Crea y entrena un modelo de clasificación básico
model = nn.Linear(4, 3)
criterion = nn.CrossEntropyLoss()
optimizer = optim.Adam(model.parameters(), lr=0.01)
model.train()
for _ in range(1000):
    optimizer.zero_grad()
    output = model(X_train)
    loss = criterion(output, y_train)
    loss.backward()
    optimizer.step()

# Crea un clasificador ART a partir del modelo de PyTorch
art_classifier = PyTorchClassifier(model=model, clip_values=(0, 1), loss=criterion, optimizer=optimizer, input_shape=(4,), nb_classes=3)

# Crea un ataque de DeepFool con ART
attack = DeepFool(art_classifier)

# Genera ejemplos adversarios
X_test_adv = attack.generate(x=X_test.numpy())

# Verifica la precisión del modelo en los ejemplos adversarios
predictions = model(Variable(torch.from_numpy(X_test_adv).float()))
_, predicted = torch.max(predictions.data, 1)
accuracy = np.sum(predicted.numpy() == y_test.numpy()) / len(y_test)
print(f'Accuracy on adversarial examples: {accuracy * 100}%')